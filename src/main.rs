use std::fmt::Display;
use std::fs::File;
use std::io::{BufRead, BufReader, BufWriter, Write};
use std::net::{Ipv4Addr, Ipv6Addr};
use std::path::Path;

use anyhow::Context;
use dns_lookup::lookup_host;

use clap::Parser;

#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq)]
enum NftablesSetType {
    Ipv4Addr,
    Ipv6Addr,
}

impl Display for NftablesSetType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.write_str(match self {
            Self::Ipv4Addr => "ipv4_addr",
            Self::Ipv6Addr => "ipv6_addr",
        })
    }
}

trait NfTablesSetItem: Display {
    fn item_type() -> NftablesSetType;
}

impl NfTablesSetItem for Ipv4Addr {
    fn item_type() -> NftablesSetType {
        NftablesSetType::Ipv4Addr
    }
}

impl NfTablesSetItem for Ipv6Addr {
    fn item_type() -> NftablesSetType {
        NftablesSetType::Ipv6Addr
    }
}

fn write_nftables_set<W: Write, T: NfTablesSetItem>(
    writer: &mut W,
    name: &str,
    elements: &[T],
) -> std::io::Result<()> {
    writer.write_fmt(format_args!(
        "set {} {{\n    type {}\n",
        name,
        T::item_type()
    ))?;
    if elements.len() > 0 {
        writer.write(b"    elements = {\n")?;
        for (i, item) in elements.iter().enumerate() {
            writer.write_fmt(format_args!("        {}", item))?;
            if i < elements.len() - 1 {
                writer.write_all(b",")?;
            }
            writer.write_all(b"\n")?;
        }
        writer.write(b"    }\n")?;
    }
    writer.write_all(b"}\n")?;
    Ok(())
}

fn write_output_file<W: Write>(
    writer: &mut W,
    ipv4_addresses: &[Ipv4Addr],
    ipv6_addresses: &[Ipv6Addr],
) -> std::io::Result<()> {
    writer.write_all(b"# Automatically generated by nftables-dns\n\n")?;
    write_nftables_set(writer, "dns_ipv4", ipv4_addresses)?;
    write_nftables_set(writer, "dns_ipv6", ipv6_addresses)?;
    Ok(())
}

fn update_nftables_ip_sets<P: AsRef<Path>>(input_file: P, output_file: P) -> anyhow::Result<()> {
    let mut ipv4_addresses = vec![];
    let mut ipv6_addresses = vec![];

    let input = BufReader::new(File::open(input_file).context("could not open input file")?);
    for line in input.lines() {
        let line = line.context("could not read input")?;
        let line = line.trim();
        if line.is_empty() {
            continue;
        }

        for address in lookup_host(line)? {
            match address {
                std::net::IpAddr::V4(address) => ipv4_addresses.push(address),
                std::net::IpAddr::V6(address) => ipv6_addresses.push(address),
            }
        }
    }

    let mut output =
        BufWriter::new(File::create(output_file).context("could not open output file")?);
    write_output_file(&mut output, &ipv4_addresses, &ipv6_addresses)
        .context("could not write output file")?;

    Ok(())
}

#[derive(Parser, Debug)]
#[command(author, version, about)]
struct Args {
    #[arg(
        short = 'i',
        long = "input",
        help = "input file (one domain per line, lines starting with # are ignored)",
        default_value = "/etc/nftables.d/dns.in"
    )]
    input_file: String,

    #[arg(
        short = 'o',
        long = "output",
        help = "output file",
        default_value = "/etc/nftables.d/dns-sets.conf"
    )]
    output_file: String,
}

fn main() -> anyhow::Result<()> {
    let args = Args::parse();
    update_nftables_ip_sets(&args.input_file, &args.output_file)
}

#[cfg(test)]
mod tests {
    use std::{
        env::temp_dir,
        fs::File,
        io::{BufReader, BufWriter, Read, Write},
        net::{Ipv4Addr, Ipv6Addr},
        vec,
    };

    use crate::{update_nftables_ip_sets, write_nftables_set};

    #[test]
    fn test_integration() {
        let temp_base = temp_dir();
        let input_path = temp_base.join("input");
        let output_path = temp_base.join("output");
        let mut input_file = BufWriter::new(File::create(&input_path).unwrap());
        input_file.write(b"localhost\n").unwrap();
        drop(input_file);

        update_nftables_ip_sets(&input_path, &output_path).unwrap();

        let mut output = String::new();
        BufReader::new(File::open(&output_path).unwrap())
            .read_to_string(&mut output)
            .unwrap();

        assert_eq!(
            output.as_str(),
            "\
# Automatically generated by nftables-dns

set dns_ipv4 {
    type ipv4_addr
    elements = {
        127.0.0.1
    }
}
set dns_ipv6 {
    type ipv6_addr
    elements = {
        ::1
    }
}
"
        );
    }

    #[test]
    fn test_write_nftables_set_ipv4_addr() {
        let mut writer = BufWriter::new(Vec::new());
        write_nftables_set(
            &mut writer,
            "test_set",
            &vec![Ipv4Addr::new(127, 0, 0, 1), Ipv4Addr::new(127, 0, 0, 2)],
        )
        .unwrap();
        let output = String::from_utf8(writer.into_inner().unwrap()).unwrap();
        assert_eq!(
            output,
            "\
set test_set {
    type ipv4_addr
    elements = {
        127.0.0.1,
        127.0.0.2
    }
}
"
        );
    }

    #[test]
    fn test_write_nftables_set_ipv4_addr_empty() {
        let mut writer = BufWriter::new(Vec::new());
        write_nftables_set::<_, Ipv4Addr>(&mut writer, "test_set", &vec![]).unwrap();
        let output = String::from_utf8(writer.into_inner().unwrap()).unwrap();
        assert_eq!(
            output,
            "\
set test_set {
    type ipv4_addr
}
"
        );
    }

    #[test]
    fn test_write_nftables_set_ipv6_addr() {
        let mut writer = BufWriter::new(Vec::new());
        write_nftables_set(
            &mut writer,
            "test_set",
            &vec![
                Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1),
                Ipv6Addr::new(1, 0, 0, 0, 0, 0, 0, 1),
            ],
        )
        .unwrap();
        let output = String::from_utf8(writer.into_inner().unwrap()).unwrap();
        assert_eq!(
            output,
            "\
set test_set {
    type ipv6_addr
    elements = {
        ::1,
        1::1
    }
}
"
        );
    }

    #[test]
    fn test_write_nftables_set_ipv6_addr_empty() {
        let mut writer = BufWriter::new(Vec::new());
        write_nftables_set::<_, Ipv6Addr>(&mut writer, "test_set", &vec![]).unwrap();
        let output = String::from_utf8(writer.into_inner().unwrap()).unwrap();
        assert_eq!(
            output,
            "\
set test_set {
    type ipv6_addr
}
"
        );
    }
}
